#!/bin/bash

# dependencies #

[ -z "${PREFIX}" ] && PREFIX="usr"

# script #

# version #

# variables #

stamp=$(date +"%m-%d-%Y-%H-%M-%S")

# defaults #

# terminal

if [ -z "$(command -v tput)" ]
then
	# ansi colors

	if [[ -t 1 ]]
	then
		black=$(echo -e \\e\[30m)
		red=$(echo -e \\e\[31m)
		green=$(echo -e \\e\[32m)
		yellow=$(echo -e \\e\[33m)
		blue=$(echo -e \\e\[34m)
		magenta=$(echo -e \\e\[35m)
		cyan=$(echo -e \\e\[36m)
		white=$(echo -e \\e\[97m)
		reset=$(echo -e \\e\[39m)
	fi
else
	# colors and attributes

	if [[ -t 1 ]]
	then
		black=$(tput setaf 0)
		red=$(tput setaf 1)
		green=$(tput setaf 2)
		yellow=$(tput setaf 3)
		blue=$(tput setaf 4)
		magenta=$(tput setaf 5)
		cyan=$(tput setaf 6)
		white=$(tput setaf 7)

		bold=$(tput bold)
		underline_start=$(tput smul)
		underline_stop=$(tput rmul)
		reverse=$(tput rev)
		blink=$(tput blink)
		invisible=$(tput invis)
		standout_start=$(tput smso)
		standout_stop=$(tput rmso)

		reset=$(tput sgr 0)														# reset all attributes

		# terminal control

		terminal_info=$(tput longname)											# full description of terminal

		terminal_height=$(tput lines)											# number of lines in terminal
		terminal_width=$(tput cols)												# number of columns in terminal
		terminal_colors=$(tput colors)											# number of colors available

		terminal_save_cursor=$(tput sc)											# save cursor position of terminal
		terminal_restore_cursor=$(tput rc)										# restore cursor position of terminal

		terminal_home_cursor=$(tput home)										# move cursor to upper left corner (0,0) Same as 'tput cup 0 0'
		terminal_move_cursor=$(tput cup ${tput_row} ${tput_col})				# move cursor to position (row, column)
		terminal_cursor_down=$(tput cud1)										# move cursor down 1 line
		terminal_cursor_up=$(tput cuu1)											# move cursor up 1 line

		terminal_cursor_hide=$(tput civis)										# set cursor to invisible state
		terminal_cursor_show=$(tput cnorm)										# set cursor to normal state

		terminal_save_screen=$(tput smcup)										# save screen contents
		terminal_restore_screen=$(tput rmcup)									# restore screen contents

		terminal_clear_right=$(tput el)											# clear from cursor to end of line - left
		terminal_clear_left=$(tput el)											# clear from cursor to beginning of line - right
		terminal_clear_down=$(tput ed)											# clear from cursor to end of the screen - down
		terminal_clear_all=$(tput clear)										# clear entire screen and home cursor (0,0) - all
	fi
fi

# markers

marker_top='[ ⋀ ]'
marker_bot='[ ⋁ ]'

marker_fwd='[ > ]'
marker_rev='[ < ]'
marker_stp='[ / ]'

marker_add='[ + ]'
marker_rem='[ - ]'

marker_ret='[ ⬢ ]'
marker_rel='[ ⬡ ]'

marker_ask='[ ? ]'
marker_inf='[ i ]'
marker_ipt='[ ± ]'
marker_msg='[ ¤ ]'
marker_wrn='[ ! ]'
marker_usr='[ • ]'

marker_yes='[ ✓ ]'
marker_not='[ ⨉ ]'

marker_nul='     '

# prompt

frobulate.prompt () {
	# initialize string return array

	frobulate.str=()

	begin="${1}"
	end="${2}"

	[ -z "${count}" ] && count="80"

	# set span width

	if [ ${#begin} -le "${count}" ]
	then
		span="--------------------------------------------------------------------------------"
	else
		span=""
	fi

	# parse arguments

	[ $# -ge 0 ] && span_character="/"											# 0 argument   - full dash line

	[ $# -eq 1 ] && span_character="/"											# 1 argument   - pad to end of line

	[ $# -eq 3 ] && span_character="${3}"										# 3 arguments  - replace span character with argument 3

	[ $# -ge 2 ] && span=${span::-6}											# 2+ arguments - reduce span by 6 characters: compensate for line marker + space
	[ $# -ge 2 ] && begin="${begin} "											# 2+ arguments - append space to 'begin' value
	[ $# -ge 2 ] && end=" ${end}"												# 2+ arguments - prepend space to 'end' value

	# fold paragraph if character count is above 80
	# indent second line onward (6 spaces) to match line marker

	if [ $# -eq 1 ] && [ "${#begin}" -ge "${count}" ]
	then
		begin=$(echo "${begin}" | fold -s -w "${count}" | sed -e '2,$s/^/      /g')
	fi

	# substitute span character

	span="${span//-/$span_character}"

	# print first argument

	span_begin=$(echo -ne "${begin}")

	# print other arguments as fixed width prompt if present

	# calculate span width - remove 6 characters for prompt header

	span_count=$(( ${#span} - ${#begin} - ${#end} ))

	# set new padding width

	if [ ${#begin} -le "${count}" ]
	then
		span=${span:0:$span_count}
	else
		span=""
	fi

	span_middle="${span}"

	span_end=$(echo -e "${end}")

	# populate array at end to avoid integrating spaces

	[ $# -ge 0 ] && frobulate.str=("${span_begin}""${span_middle}""${span_end}")

	[ $# -eq 1 ] && frobulate.str=("${span_begin}")

	[ $# -ge 2 ] && frobulate.str=("${span_begin}""${span_middle}""${span_end}")

	[ $# -eq 3 ] && frobulate.str=("${span_begin}""${span_middle}""${span_end}")
}

# highlights

frobulate.red () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${red}${value}${reset}"
}

frobulate.green () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${green}${value}${reset}"
}

frobulate.yellow () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${yellow}${value}${reset}"
}

frobulate.blue () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${blue}${value}${reset}"
}

frobulate.magenta () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${magenta}${value}${reset}"
}

frobulate.cyan () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${cyan}${value}${reset}"
}

# prompts #

frobulate.maru () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${green}${marker_maru} ${value}${reset}"
}

frobulate.batsu () {
	value="${frobulate.str[@]}"
	frobulate.prompt "$@"

	echo -e "${red}${marker_batsu} ${value}${reset}"
}

frobulate.bako () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${white}${marker_bako} ${value}${reset}"
}

frobulate.sankaku () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${cyan}${marker_sankaku} ${value}${reset}"
}

frobulate.inf() {
	frobulate.prompt "${@}"
	value="${frobulate.str[@]}"

	echo -e "${blue}${marker_inf} ${value}${reset}"
}

frobulate.msg () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${cyan}${marker_msg} ${value}${reset}"
}

frobulate.wrn () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${yellow}${marker_wrn} ${value}${reset}"
}

frobulate.add () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${blue}${marker_add} ${value}${reset}"
}

frobulate.rem () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${red}${marker_rem} ${value}${reset}"
}

frobulate.ret () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${cyan}${marker_ret} ${value}${reset}"
}

frobulate.rel () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${magenta}${marker_rel} ${value}${reset}"
}

frobulate.fwd () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${white}${marker_fwd} ${value}${reset}"
}

frobulate.rev () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${white}${marker_rev} ${value}${reset}"
}

frobulate.stp () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${white}${marker_stp} ${value}${reset}"
}

frobulate.dwl () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${magenta}${marker_bot} ${value}${reset}"
}

frobulate.upl () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${magenta}${marker_top} ${value}${reset}"
}

frobulate.lnk () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${magenta}${marker_stp} ${value}${reset}"
}

frobulate.scs () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${green}${marker_yes} ${value}${reset}"
}

frobulate.err () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${red}${marker_not} ${value}${reset}"
}

frobulate.ins () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${magenta}${marker_ipt} ${value}${reset}"
}

# prompt inputs

# no new line after prompt: keeps user input beside prompt
# includes space after value to separate input
# use for questions, input, user values

frobulate.ask () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -ne "${magenta}${marker_ask} ${value} ${reset}"
}

frobulate.ipt () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -ne "${magenta}${marker_add} ${value} ${reset}"
}

frobulate.usr () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -ne "${magenta}${marker_usr} ${value} ${reset}"
}

# numbering

# use to mark directives or instructions

frobulate.num () {
	before="[ "
	after=" ]"

	number="${1}"

	shift

	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${before}${number}${after} ${value}"
}

# prompt separator

# no marker
# use to separate notices and messages from execution blocks

frobulate.sep () {
	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	echo -e "${value}"
}

# separate

# predefined separator:
# use to separate instructions or warnings from prompts

frobulate.separate () {

	frobulate.sep
	echo
}

# prompt script title

# generic title from script name

frobulate.script () {
	description="${1}"

	frobulate.msg "${description}" "[ ${script%-*} // ${version} ]"
}

# wait

frobulate.wait () {
	# wait in seconds

	seconds="${1}"

	# set defaults

	[ -z "${seconds}" ] && seconds="1"

	sleep "${seconds}"
}

# countdown

frobulate.countdown () {
	before="[ "
	after=" ]"

	seconds="$1"

	shift

	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	shift

	while [ "${seconds}" -ge 0 ]
	do
		echo -ne "\r${before}${red}$((seconds--))${reset}${after} ${value}\c"

		sleep 1
	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# progress

frobulate.progress () {
	# catch PID of last command

	PID=$!

	# spinner="\/"

	spinner="⬒◩◧⬕⬓◪◨⬔"
	before="[ "
	after=" ]"

	frobulate.prompt "$@"
	value="${frobulate.str[@]}"

	i=1

	while [ -d /proc/"${PID}" ]
	do
		echo -ne "\r${before} \b${spinner:i++%${#spinner}:1}${after} ${value}\c "

		sleep 0.1
	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# directory

frobulate.directory () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		directory="${2}"

		list=()

		list+=("${directory}")
	fi

	for directory in ${list[@]}
	do
		frobulate.add "Creating directory" "[ ${directory} ]"
		echo

		# create directory and set permissions

		[ ! -d "${path}"/"${directory}" ] && mkdir -p "${path}"/"${directory}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${directory}"
	done

	# unset array

	list=()
}

# type

frobulate.type () {
	for (( character=0; character<=${#1}; character++ ))
	do
		interval=$(( (RANDOM % 5) + 1 ))
		sleep="0.${interval}"

		printf "%s" "${1:${character}:1}"

		sleep "${sleep}"
	done

	printf '\n'
}

# write

frobulate.write () {
	content="${1}"
	path="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${path}" ] && mkdir -p "${path}"

	for file in ${list[@]}
	do
		frobulate.add "Writing" "[ ${file} ]"
		echo

		# write to file and set permissions

		echo "${content}" >> "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"

		# set permissions

		chmod a+rx "${path}"/"${file}"
	done
}

# file

frobulate.file () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${path}" ] && mkdir -p "${path}"

	for file in ${list[@]}
	do
		frobulate.add "Creating" "[ ${file} ]"
		echo

		# create file and set permissions

		[ ! -f "${path}"/"${file}" ] && touch "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"
	done

	# unset array

	list=()
}

# keep

frobulate.keep () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	cd "${path}" || exit 1

	for item in *
	do
		keep=0

		for file in ${list[@]}
		do
			# mark for keeping

			if [[ "${path}"/"$file" = "${path}"/"$item" ]]
			then
				keep=1

				frobulate.ret "Keeping" "[ ${file} ]"
				echo
			fi
		done

		# remove unmarked items

		[[ "$keep" = 0 ]] && rm -rf "${item}"
	done

	# unset array

	list=()
}

# delete

frobulate.delete () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	for file in ${list[@]}
	do
		frobulate.rem "Deleting" "[ ${file} ]"
		echo

		# remove file

		rm -rf "${path}"/"${file}"
	done

	# unset array

	list=()
}

# copy

frobulate.copy () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${target}" ] && mkdir -p "${target}"

	for file in ${list[@]}
	do
		frobulate.lnk "Copying" "[ ${file} ]"
		echo

		cp -r -f "${source}"/"${file}" "${target}"/"${file}"
	done

	# unset array

	list=()
}

# link

frobulate.link () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${target}" ] && mkdir -p "${target}"

	for file in ${list[@]}
	do
		console.lnk "Linking" "[ ${file} ]"
		echo

		ln -s -f "${source}"/"${file}" "${target}"/"${file}"
	done

	# unset array

	list=()
}

# get

frobulate.get () {
	# parse url and download file according to source concatenation

	command_get () {
		# verify url status

		url_status=$(curl						\
				--write-out "%{http_code}\n"	\
				--silent						\
				--output /dev/null				\
												"${source}"/"${file}"
					)

		if [[ "${url_status}" = [145][0-9][0-9] ]]
		then
			curl -s -L "${source}" > "${path}"/"${file}"

		else
			curl -s -L "${source}"/"${file}" > "${path}"/"${file}"

		fi
	}

	command_get &

	frobulate.progress "Downloading" "[ ${file} ]"
	echo

	chmod a+rx "${path}"/"${file}"
}

# download

frobulate.download () {
	source="${1}"
	path="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${3} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${path}" ] && mkdir -p "${path}"

	frobulate.dwl "Loading..."
	echo

	for file in ${list[@]}
	do
		frobulate.get
	done

	# unset array

	list=()
}

# put

frobulate.put () {
	type="${1}"

	curl									\
		-X POST "${destination}/${file}"	\
		-H "Content-Type: ${type}"			\
		-d "${file}" &

	frobulate.progress "Uploading" "[ ${file} ]"
	echo
}

# upload

frobulate.upload () {

	frobulate.upl "Loading..."
	echo

	frobulate.put

}

# silence

frobulate.silence () {
	# wrap command execution and redirect all output to null sink:
	# provides fully silent execution

	command="$@"

	"${SHELL}" -c "${command}" >> /dev/null 2>&1
}

# log

frobulate.log () {
	# wrap command execution and redirect all output to /var log file:
	# provides logged and fully silent execution

	command="$@"

	"${SHELL}" -c "${command}" >> "${PREFIX}"/var/log/"${script}"-"${stamp}".log 2>&1
}

# password

frobulate.password () {
	# obfuscate password input with custom mask

	mask_character="•"

	while  read -p "${mask}" -r -s -n 1 input_character
	do
		# enter / accept password

		if [[ "${input_character}" == $'\0' ]]
		then
			# break on 'NUL'

			break
		fi

		# handle backspace / delete character input

		if [[ "${input_character}" == $'\177' ]]
		then
			# remove input on 'BACKSPACE'/'DEL'

			mask=$'\b \b'
			password="${password%?}"
		else
			# set character mask

			mask="${mask_character}"

			# append user input and fomr password

			password+="${input_character}"
		fi
	done

	input="${password}"

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# input

frobulate.input () {
	list=($@)

	for value in "${list[@]}"
	do
		label=${value^}
		prompt="$(echo ${label} | sed 's/_/ /'):"

		frobulate.ipt "${prompt}"

		[[ "${value}" = *password* ]] && frobulate.password || read input

		# prevent empty input

		while true
		do
			if [ -z "${input}" ]
			then
				echo
				frobulate.err "${prompt%:} cannot be empty."
				echo

				prompt="$(echo ${label} | sed 's/_/ /'):"

				frobulate.ipt "${prompt}"

				[[ "${value}" = *password* ]] && frobulate.password || read input
			else
					break
			fi
		done

		value=${label,}

		frobulate.rtn+=("${value}=${input}")

	done

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# clean

frobulate.clean () {
	command_autoremove="apt-get autoremove"
	command_clean="apt-get clean"

	frobulate.log "${command_autoremove}" &

	frobulate.progress "Flushing packages..."
	echo

	frobulate.log "${command_clean}" &

	frobulate.progress "Cleaning..."
	echo

	# fix dpkg lock and errors:
	# remove all post-install logs - prevent package configuration errors

	[ -d "${PREFIX}"/var/lib/dpkg/info ] && rm -rf "${PREFIX}"/var/lib/dpkg/info/*.postinst
}

# hold

frobulate.hold () {
	export DEBIAN_FRONTEND=noninteractive

	list=($@)

	command_hold="apt-mark hold"

	frobulate.inf "Holding packages."
	echo

	for package in ${list[@]}
	do
		frobulate.wrn "Holding" "[ '${package}' ]"
		echo

		frobulate.log "${command_hold} ${package}" &

		frobulate.progress "Holding..."
		echo
	done

	# unset array

	list=()
}

# release

frobulate.release () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_unhold="apt-mark unhold"

	frobulate.inf "Releasing packages."
	echo

	for package in ${list[@]}
	do
		frobulate.wrn "Releasing" "[ '${package}' ]"
		echo

		frobulate.log "${command_unhold} ${package}" &

		frobulate.progress "Releasing..."
		echo
	done

	# unset array

	list=()
}

# failsafe

frobulate.failsafe () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_update="apt-get update"
	command_upgrade="apt-get upgrade"
	command_install="apt-get install"

	while [[ -z $(command -v "${package}") ]]
	do
		for package in ${list[@]}
		do
		   frobulate.log "yes | ${command_update}"

		   frobulate.log "yes | ${command_upgrade}"

		   frobulate.log "yes | ${command_install}" "${package}"

		   frobulate.log "yes | $command_update"
		done
	done
}

# install

frobulate.install () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_install="apt-get install"

	frobulate.inf "Installing packages."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -i -o installed)" ]
		then
			frobulate.wrn "Package not installed" "[ '${package}' ]"
			echo

			frobulate.log "yes | ${command_install} ${package}" &

			frobulate.progress "Installing..."
			echo
		else
			frobulate.scs "Package installed" "[ '${package}' ]"
			echo

			frobulate.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	frobulate.clean
}

# install

frobulate.install.minimal () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	# use '--no-install-recommends' option to keep bloat to a minimum

	command_install="apt-get install --no-install-recommends --no-upgrade"

	frobulate.inf "Installing minimal package requirements."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -i -o installed)" ]
		then
			frobulate.wrn "Package not installed" "[ '${package}' ]"
			echo

			frobulate.log "yes | ${command_install} ${package}" &

			frobulate.progress "Installing..."
			echo
		else
			frobulate.scs "Package installed" "[ '${package}' ]"
			echo

			frobulate.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	frobulate.clean
}

# reinstall

frobulate.reinstall () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_reinstall="apt-get install --reinstall"

	frobulate.inf "Reinstalling packages."
	echo

	for package in ${list[@]}
	do
		frobulate.log "yes | ${command_reinstall} ${package}" &

		frobulate.progress "Reinstalling..."
		echo
	done

	# unset array

	list=()

	# cleanup

	frobulate.clean
}

# update

frobulate.update () {
	export DEBIAN_FRONTEND=noninteractive

	command_update="apt-get update"

	frobulate.inf "Processing package and repository information."
	echo

	frobulate.log "${command_update}" &

	frobulate.progress "Updating..."
	echo
}

# upgrade

frobulate.upgrade () {
	export DEBIAN_FRONTEND=noninteractive

	command_upgrade="apt-get upgrade"

	frobulate.inf "Processing installed packages."
	echo

	frobulate.log "yes | ${command_upgrade}" &

	frobulate.progress "Upgrading..."
	echo
}

# purge

frobulate.purge () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_purge="sudo apt-get purge"

	frobulate.inf "Purging selected packages."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -o installed)" ]
		then
			frobulate.wrn "Selected package" "[ '${package}' ]"
			echo

			frobulate.log "yes | ${command_purge} ${package}" &

			frobulate.progress "Purging..."
			echo
		else
			frobulate.scs "Package not installed" "[ '${package}' ]"
			echo

			frobulate.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	frobulate.clean
}

# dialog

frobulate.dialog () {

	# dialog window title

	title="${script%.sh} - ${1}"

	# gtk dialog - zenity

	g_dialog () {
		zenity						\
			--file-selection		\
			--multiple				\
			--directory				\
			--separator=$'\n'		\
			--title="${title}"		"${@}"
	}

	# kde dialog - kdialog

	k_dialog () {
		kdialog						\
			--getopenfilename		\
			--multiple				\
			--separate-output		\
			--title "${title}"		"${@}"
	}

	# define dialog usage

	if [[ $(command -v zenity) ]]
	then
		dialog=$(g_dialog)

	elif [[ $(command -v kdialog) ]]
	then
		dialog=$(k_dialog)
	else
		frobulate.wrn "'dialog' not installed."
		frobulate.wrn "This utility must be run using the 'directory' option."
		echo

		frobulate.fwd "Exiting..."
		echo

		exit 1
	fi
}

# clear

frobulate.clear () {
	frobulate.wait

	clear
}

# terminate

frobulate.terminate () {
	process_name="${1}"

	[[ $(command -v pgrep) ]] && process_id=$(pgrep -f "${process_name}")
	[[ $(command -v ps) ]]    && process_id=$(ps -A | grep "${process_name}" | cut -d ' ' -f 1)

	[[ $(command -v kill) ]]  && terminate_command=$(kill -9 ${process_id})
	[[ $(command -v pkill) ]] && terminate_command=$(pkill ${process_name})

	"${terminate_command}"
}

# exit

frobulate.exit () {
	instance="${1}"

	frobulate.countdown 3 "Exiting" "[ ${instance} ]"

	frobulate.kill "${SHELL}"
}

# trap

frobulate.result () {
	checkpoint="${1}"
	instance="${2}"

	if [[ $(command -v "${checkpoint}") ]]
	then
		frobulate.scs "Setup complete" "[ ${instance} ]"
		echo
	else
		frobulate.err "Setup errors were encountered" "[ ${instance} ]"
		echo

		frobulate.inf "Consult setup logs for details" '[ ${PREFIX}/var/log/ ]'
		echo
	fi
}

frobulate.trap () {
	instance="${1}"

	[ $# -eq 1 ] && signal="EXIT" || signal="${2}"

	trap "${instance}" "${signal}"
}

frobulate.user () {
	frobulate.inf "Current user name is ${SUDO_USER:-$USER}."

	sleep 1
}
