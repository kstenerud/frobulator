#!/bin/bash

# dependencies /////////////////////////////////////////////////////////////////

# script ///////////////////////////////////////////////////////////////////////

# version //////////////////////////////////////////////////////////////////////

# variables ////////////////////////////////////////////////////////////////////

stamp=$(date +"%m-%d-%Y-%H-%M-%S")

# defaults /////////////////////////////////////////////////////////////////////

# colors ///////////////////////////////////////////////////////////////////////

if [ -z "$(command -v tput)" ]
then
	# ansi color escapes

	if [[ -t 1 ]]
	then
		black=$(echo -e \\e\[30m)
		red=$(echo -e \\e\[31m)
		green=$(echo -e \\e\[32m)
		yellow=$(echo -e \\e\[33m)
		blue=$(echo -e \\e\[34m)
		magenta=$(echo -e \\e\[35m)
		cyan=$(echo -e \\e\[36m)
		white=$(echo -e \\e\[97m)
		reset=$(echo -e \\e\[39m)
	fi
else
	# 'tput' colors and attributes

	if [[ -t 1 ]]
	then
		# define colors

		black=$(tput setaf 0)
		red=$(tput setaf 1)
		green=$(tput setaf 2)
		yellow=$(tput setaf 3)
		blue=$(tput setaf 4)
		magenta=$(tput setaf 5)
		cyan=$(tput setaf 6)
		white=$(tput setaf 7)

		# define formatting

		bold=$(tput bold)
		underline_start=$(tput smul)
		underline_stop=$(tput rmul)
		reverse=$(tput rev)
		blink=$(tput blink)
		invisible=$(tput invis)
		standout_start=$(tput smso)
		standout_stop=$(tput rmso)

		# reset all attributes

		reset=$(tput sgr 0)

		# 'tput' terminal control

		# full description of terminal

		terminal_info=$(tput longname)

		# number of lines in terminal
		terminal_height=$(tput lines)

		# number of columns in terminal

		terminal_width=$(tput cols)

		# number of colors available

		terminal_colors=$(tput colors)

		# save cursor position of terminal

		terminal_save_cursor=$(tput sc)

		# restore cursor position of terminal

		terminal_restore_cursor=$(tput rc)

		# move cursor to upper left corner (0,0) - same as 'tput cup 0 0'

		terminal_home_cursor=$(tput home)

		# move cursor to position (row, column)

		terminal_move_cursor=$(tput cup ${tput_row} ${tput_col})

		# move cursor down 1 row

		terminal_cursor_down=$(tput cud1)

		# move cursor up 1 row

		terminal_cursor_up=$(tput cuu1)

		# set cursor to invisible state

		terminal_cursor_hide=$(tput civis)

		# set cursor to normal state

		terminal_cursor_show=$(tput cnorm)

		# save screen contents

		terminal_save_screen=$(tput smcup)

		# restore screen contents

		terminal_restore_screen=$(tput rmcup)

		# clear from cursor to end of line - left

		terminal_clear_right=$(tput el1)

		# clear from cursor to beginning of line - right

		terminal_clear_left=$(tput el)

		# clear from cursor to end of the screen - down

		terminal_clear_down=$(tput ed)

		# clear entire screen and home cursor (0,0) - all

		terminal_clear_all=$(tput clear)
	fi
fi

# markers //////////////////////////////////////////////////////////////////////

marker_top='[ ⋀ ]'
marker_bot='[ ⋁ ]'

marker_fwd='[ > ]'
marker_rev='[ < ]'
marker_stp='[ / ]'

marker_add='[ + ]'
marker_rem='[ - ]'

marker_ret='[ ⬢ ]'
marker_rel='[ ⬡ ]'

marker_ask='[ ? ]'
marker_inf='[ i ]'
marker_ipt='[ ± ]'
marker_msg='[ ¤ ]'
marker_wrn='[ ! ]'
marker_usr='[ • ]'

marker_yes='[ ✓ ]'
marker_not='[ ⨉ ]'

marker_nul='     '

# prompt ///////////////////////////////////////////////////////////////////////

frobulator.prompt () {
	# initialize string return array

	frobulate_str=()

	begin="${1}"
	end="${2}"

	if [ -z "${count}" ]
	then
		count="80"
	fi

	# set span width

	if [ ${#begin} -le "${count}" ]
	then
		span="--------------------------------------------------------------------------------"
	else
		span=""
	fi

	# parse arguments

	# 0 argument   - full dash line

	if [ $# -ge 0 ]
	then
		span_character="/"
	fi

	# 1 argument   - pad to end of line

	if [ $# -eq 1 ]
	then
		span_character="/"
	fi

	# 3 arguments  - replace span character with argument 3

	if [ $# -eq 3 ]
	then
		span_character="${3}"
	fi

	# 2+ arguments - reduce span by 6 characters: compensate for line marker + space

	if [ $# -ge 2 ]
	then
		span=${span::-6}
	fi

	# 2+ arguments - append space to 'begin' value

	if [ $# -ge 2 ]
	then
		begin="${begin} "
	fi

	# 2+ arguments - prepend space to 'end' value

	if [ $# -ge 2 ]
	then
		end=" ${end}"
	fi

	# fold paragraph if character count is above 80
	# indent second line onward (6 spaces) to match line marker

	if [ $# -eq 1 ] && [ "${#begin}" -ge "${count}" ]
	then
		begin=$(echo "${begin}" | fold -s -w "${count}" | sed -e '2,$s/^/      /g')
	fi

	# substitute span character

	span="${span//-/$span_character}"

	# print first argument

	span_begin=$(echo -ne "${begin}")

	# print other arguments as fixed width prompt if present

	# calculate span width - remove 6 characters for prompt header

	span_count=$(( ${#span} - ${#begin} - ${#end} ))

	# set new padding width

	if [ ${#begin} -le "${count}" ]
	then
		span=${span:0:$span_count}
	else
		span=""
	fi

	span_middle="${span}"

	span_end=$(echo -e "${end}")

	# populate array at end to avoid integrating spaces

	if [ $# -ge 0 ]
	then
		frobulate_str=("${span_begin}""${span_middle}""${span_end}")
	fi

	if [ $# -eq 1 ]
	then
		frobulate_str=("${span_begin}")
	fi

	if [ $# -ge 2 ]
	then
		frobulate_str=("${span_begin}""${span_middle}""${span_end}")
	fi

	if [ $# -eq 3 ]
	then
		frobulate_str=("${span_begin}""${span_middle}""${span_end}")
	fi
}

# highlights ///////////////////////////////////////////////////////////////////

frobulator.red () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${red}${value}${reset}"
}

frobulator.green () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${green}${value}${reset}"
}

frobulator.yellow () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${yellow}${value}${reset}"
}

frobulator.blue () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${blue}${value}${reset}"
}

frobulator.magenta () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${magenta}${value}${reset}"
}

frobulator.cyan () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${cyan}${value}${reset}"
}

# prompts //////////////////////////////////////////////////////////////////////

frobulator.maru () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${green}${marker_maru} ${value}${reset}"
}

frobulator.batsu () {
	value="${frobulate_str[@]}"
	frobulator.prompt "$@"

	echo -e "${red}${marker_batsu} ${value}${reset}"
}

frobulator.bako () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${white}${marker_bako} ${value}${reset}"
}

frobulator.sankaku () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${cyan}${marker_sankaku} ${value}${reset}"
}

frobulator.inf() {
	frobulator.prompt "${@}"
	value="${frobulate_str[@]}"

	echo -e "${blue}${marker_inf} ${value}${reset}"
}

frobulator.msg () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${cyan}${marker_msg} ${value}${reset}"
}

frobulator.wrn () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${yellow}${marker_wrn} ${value}${reset}"
}

frobulator.add () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${blue}${marker_add} ${value}${reset}"
}

frobulator.rem () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${red}${marker_rem} ${value}${reset}"
}

frobulator.ret () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${cyan}${marker_ret} ${value}${reset}"
}

frobulator.rel () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${magenta}${marker_rel} ${value}${reset}"
}

frobulator.fwd () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${white}${marker_fwd} ${value}${reset}"
}

frobulator.rev () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${white}${marker_rev} ${value}${reset}"
}

frobulator.stp () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${white}${marker_stp} ${value}${reset}"
}

frobulator.dwl () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${magenta}${marker_bot} ${value}${reset}"
}

frobulator.upl () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${magenta}${marker_top} ${value}${reset}"
}

frobulator.lnk () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${magenta}${marker_stp} ${value}${reset}"
}

frobulator.scs () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${green}${marker_yes} ${value}${reset}"
}

frobulator.err () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${red}${marker_not} ${value}${reset}"
}

frobulator.ins () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${magenta}${marker_ipt} ${value}${reset}"
}

# prompt inputs ////////////////////////////////////////////////////////////////

# no new line after prompt: keeps user input beside prompt
# includes space after value to separate input
# use for questions, input, user values

frobulator.ask () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -ne "${magenta}${marker_ask} ${value} ${reset}"
}

frobulator.ipt () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -ne "${magenta}${marker_add} ${value} ${reset}"
}

frobulator.usr () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -ne "${magenta}${marker_usr} ${value} ${reset}"
}

# numbering ////////////////////////////////////////////////////////////////////

# use to mark directives or instructions

frobulator.num () {
	before="[ "
	after=" ]"

	number="${1}"

	shift

	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${before}${number}${after} ${value}"
}

# separator ////////////////////////////////////////////////////////////////////

# no marker
# use to separate notices and messages from execution blocks

frobulator.sep () {
	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	echo -e "${value}"
}

# separate /////////////////////////////////////////////////////////////////////

# predefined separator:
# use to separate instructions or warnings from prompts

frobulator.separate () {

	frobulator.sep
	echo
}

# prompt script title

# generic title from script name

frobulator.script () {
	description="${1}"

	if [[ "${description}" = *-* ]]
	then
		message="${script%-*} // ${version}"
	else
		message="${script}"
	fi

	frobulator.msg "${description}" "[ ${message} ]"

}

# wait /////////////////////////////////////////////////////////////////////////

frobulator.wait () {
	# wait in seconds

	seconds="${1}"

	# set defaults

	if [ -z "${seconds}" ]
	then
		seconds="1"
	fi

	sleep "${seconds}"
}

# clear ////////////////////////////////////////////////////////////////////////

frobulator.clear () {
	frobulator.wait

	clear
}

# countdown ////////////////////////////////////////////////////////////////////

frobulator.countdown () {
	before="[ "
	after=" ]"

	seconds="$1"

	shift

	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	shift

	while [ "${seconds}" -ge 0 ]
	do
		echo -ne "\r${before}${red}$((seconds--))${reset}${after} ${value}\c"

		sleep 1
	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# progress /////////////////////////////////////////////////////////////////////

frobulator.progress () {
	# catch PID of last command

	PID=$!

	# spinner="\/"

	spinner="⬒◩◧⬕⬓◪◨⬔"
	before="[ "
	after=" ]"

	frobulator.prompt "$@"
	value="${frobulate_str[@]}"

	i=1

	while [ -d /proc/"${PID}" ]
	do
		echo -ne "\r${before} \b${spinner:i++%${#spinner}:1}${after} ${value}\c "

		sleep 0.1
	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# directory ////////////////////////////////////////////////////////////////////

frobulator.directory () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		directory="${2}"

		list=()

		list+=("${directory}")
	fi

	for directory in ${list[@]}
	do
		frobulator.add "Creating directory" "[ ${directory} ]"
		echo

		# create directory and set permissions

		if [ ! -d "${path}"/"${directory}" ]
		then
			mkdir -p "${path}"/"${directory}"
		fi

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${directory}"
	done

	# unset array

	list=()
}

# type /////////////////////////////////////////////////////////////////////////

frobulator.type () {
	for (( character=0; character<=${#1}; character++ ))
	do
		interval=$(( (RANDOM % 5) + 1 ))
		sleep="0.${interval}"

		printf "%s" "${1:${character}:1}"

		sleep "${sleep}"
	done

	printf '\n'
}

# write ////////////////////////////////////////////////////////////////////////

frobulator.write () {
	content="${1}"
	path="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${path}" ]
	then
		mkdir -p "${path}"
	fi

	for file in ${list[@]}
	do
		frobulator.add "Writing" "[ ${file} ]"
		echo

		# write to file and set permissions

		echo "${content}" >> "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"

		# set permissions

		chmod a+rx "${path}"/"${file}"
	done
}

# file /////////////////////////////////////////////////////////////////////////

frobulator.file () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${path}" ]
	then
		 mkdir -p "${path}"
	fi

	for file in ${list[@]}
	do
		frobulator.add "Creating" "[ ${file} ]"
		echo

		# create file and set permissions

		if [ ! -f "${path}"/"${file}" ]
		then
			touch "${path}"/"${file}"
		fi

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"
	done

	# unset array

	list=()
}

# keep /////////////////////////////////////////////////////////////////////////

frobulator.keep () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	cd "${path}" || exit 1

	for item in *
	do
		keep=0

		for file in ${list[@]}
		do
			# mark for keeping

			if [[ "${path}"/"$file" = "${path}"/"$item" ]]
			then
				keep=1

				frobulator.ret "Keeping" "[ ${file} ]"
				echo
			fi
		done

		# remove unmarked items

		if [[ "$keep" = 0 ]]
		then
			rm -rf "${item}"
		fi
	done

	# unset array

	list=()
}

# delete ///////////////////////////////////////////////////////////////////////

frobulator.delete () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	for file in ${list[@]}
	do
		frobulator.rem "Deleting" "[ ${file} ]"
		echo

		# remove file

		rm -rf "${path}"/"${file}"
	done

	# unset array

	list=()
}

# copy /////////////////////////////////////////////////////////////////////////

frobulator.copy () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${target}" ]
	then
		mkdir -p "${target}"
	fi

	for file in ${list[@]}
	do
		frobulator.lnk "Copying" "[ ${file} ]"
		echo

		cp -r -f "${source}"/"${file}" "${target}"/"${file}"
	done

	# unset array

	list=()
}

# link /////////////////////////////////////////////////////////////////////////

frobulator.link () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${target}" ]
	then
		mkdir -p "${target}"
	fi

	for file in ${list[@]}
	do
		if [ -e "${source}"/"${file}" ]
		then
			if [ $# -eq 3 ]
			then
				file=${list[0]}
				link=${list[0]}
			fi

			if [ $# -eq 4 ]
			then
				file=${list[0]}
				link=${list[1]}
			fi

			frobulator.lnk "Linking" "[ ${file} ]"
			echo

			ln -s -f "${source}"/"${file}" "${target}"/"${link}"
		fi
	done

	# unset array

	list=()
}

# get //////////////////////////////////////////////////////////////////////////

frobulator.get () {
	# parse url and download file according to source concatenation

	command_get () {
		# verify url status

		url_status=$(curl						\
				--write-out "%{http_code}\n"	\
				--silent						\
				--output /dev/null				\
												"${source}"/"${file}"
					)

		if [[ "${url_status}" = [145][0-9][0-9] ]]
		then
			curl -s -L "${source}" > "${path}"/"${file}"

		else
			curl -s -L "${source}"/"${file}" > "${path}"/"${file}"

		fi
	}

	command_get &

	frobulator.progress "Downloading" "[ ${file} ]"
	echo

	chmod a+rx "${path}"/"${file}"
}

# download /////////////////////////////////////////////////////////////////////

frobulator.download () {
	source="${1}"
	path="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${3} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${path}" ]
	then
		mkdir -p "${path}"
	fi

	frobulator.dwl "Loading..."
	echo

	for file in ${list[@]}
	do
		frobulator.get
	done

	# unset array

	list=()
}

# put

frobulator.put () {
	type="${1}"

	curl									\
		-X POST "${destination}/${file}"	\
		-H "Content-Type: ${type}"			\
		-d "${file}" &

	frobulator.progress "Uploading" "[ ${file} ]"
	echo
}

# upload ///////////////////////////////////////////////////////////////////////

frobulator.upload () {

	frobulator.upl "Loading..."
	echo

	frobulator.put

}

# silence //////////////////////////////////////////////////////////////////////

frobulator.silence () {
	# wrap command execution and redirect all output to null sink:
	# provides fully silent execution

	command="${@}"

	"${SHELL}" -c "${command}" >> /dev/null 2>&1
}

# log //////////////////////////////////////////////////////////////////////////

frobulator.log () {
	# wrap command execution and redirect all output to /var log file:
	# provides logged and fully silent execution

	command="${@}"

	"${SHELL}" -c "${command}" >> "${PREFIX}"/var/log/"${script}"-"${stamp}".log 2>&1
}

# password /////////////////////////////////////////////////////////////////////

frobulator.password () {
	# obfuscate password input with custom mask

	mask_character="•"

	while  read -p "${mask}" -r -s -n 1 input_character
	do
		# enter / accept password

		if [[ "${input_character}" == $'\0' ]]
		then
			# break on 'NUL'

			break
		fi

		# handle backspace / delete character input

		if [[ "${input_character}" == $'\177' ]]
		then
			# remove input on 'BACKSPACE'/'DEL'

			mask=$'\b \b'
			password="${password%?}"
		else
			# set character mask

			mask="${mask_character}"

			# append user input and fomr password

			password+="${input_character}"
		fi
	done

	input="${password}"

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# input ////////////////////////////////////////////////////////////////////////

frobulator.input () {
	list=($@)

	for value in "${list[@]}"
	do
		label=${value^}
		prompt="$(echo ${label} | sed 's/_/ /'):"

		frobulator.ipt "${prompt}"

		if [[ "${value}" = *password* ]]
		then
			frobulator.password
		else
			read input
		fi

		# prevent empty input

		while true
		do
			if [ -z "${input}" ]
			then
				echo
				frobulator.err "${prompt%:} cannot be empty."
				echo

				prompt="$(echo ${label} | sed 's/_/ /'):"

				frobulator.ipt "${prompt}"

				if [[ "${value}" = *password* ]]
				then
					frobulator.password
				else
					read input
				fi
			else
				break
			fi
		done

		value=${label,}

		frobulate_rtn+=("${value}=${input}")

	done

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# clean ////////////////////////////////////////////////////////////////////////

frobulator.clean () {
	command_autoremove="apt-get autoremove"
	command_clean="apt-get clean"

	frobulator.log "${command_autoremove}" &

	frobulator.progress "Flushing packages..."
	echo

	frobulator.log "${command_clean}" &

	frobulator.progress "Cleaning..."
	echo

	# fix dpkg lock and errors:
	# remove all post-install logs - prevent package configuration errors

	if [ -d "${PREFIX}"/var/lib/dpkg/info ]
	then
		rm -rf "${PREFIX}"/var/lib/dpkg/info/*.postinst
	fi
}

# hold /////////////////////////////////////////////////////////////////////////

frobulator.hold () {
	export DEBIAN_FRONTEND=noninteractive

	list=($@)

	command_hold="apt-mark hold"

	frobulator.inf "Holding packages."
	echo

	for package in ${list[@]}
	do
		frobulator.wrn "Holding" "[ '${package}' ]"
		echo

		frobulator.log "${command_hold} ${package}" &

		frobulator.progress "Holding..."
		echo
	done

	# unset array

	list=()
}

# release /////////////////////////////////////////////////////////////////////#

frobulator.release () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_unhold="apt-mark unhold"

	frobulator.inf "Releasing packages."
	echo

	for package in ${list[@]}
	do
		frobulator.wrn "Releasing" "[ '${package}' ]"
		echo

		frobulator.log "${command_unhold} ${package}" &

		frobulator.progress "Releasing..."
		echo
	done

	# unset array

	list=()
}

# failsafe /////////////////////////////////////////////////////////////////////

frobulator.failsafe () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_update="apt-get --assume-yes update"
	command_upgrade="apt-get --assume-yes upgrade"
	command_install="apt-get --assume-yes install"

	for package in ${list[@]}
	do
		while [[ -z $(command -v "${package}") ]]
		do
			frobulator.log "${command_update}"

			frobulator.log "${command_upgrade}"

			frobulator.log "${command_install} ${package}"

			frobulator.log "${command_update}"
		done
	done
}

# install //////////////////////////////////////////////////////////////////////

frobulator.install () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_install="apt-get --assume-yes install"

	frobulator.inf "Installing packages."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -i -o installed)" ]
		then
			frobulator.wrn "Package not installed" "[ '${package}' ]"
			echo

			frobulator.log "${command_install} ${package}" &

			frobulator.progress "Installing..."
			echo
		else
			frobulator.scs "Package installed" "[ '${package}' ]"
			echo

			frobulator.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	frobulator.clean
}

# command //////////////////////////////////////////////////////////////////////

frobulator.require () {
	export DEBIAN_FRONTEND=noninteractive

	frobulator.failsafe apt-file

	frobulator.log "apt-file update"

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		command="${1}"

		list=()

		list+=("${command}")
	fi

	for command in ${list[@]}
	do
		command_query=$(apt-file search -l "${PREFIX}"/bin/"${command}")

		if [[ -z $(command -v "${command}") ]]
		then
			if [[ -z "${command_query}" ]]
			then
				frobulator.err "No package found that provides command" "[ '${command}' ]"
				echo
			else
				list+=("${command_query}")

				# install

				if [[ -n "${#list[@]}" ]]
				then
					frobulator.install ${list[@]}
				fi

				# unset array

				list=()
			fi
		fi
	done
}

# reinstall ////////////////////////////////////////////////////////////////////

frobulator.reinstall () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_reinstall="apt-get --assume-yes install --reinstall"

	frobulator.inf "Reinstalling packages."
	echo

	for package in ${list[@]}
	do
		frobulator.log "${command_reinstall} ${package}" &

		frobulator.progress "Reinstalling..."
		echo
	done

	# unset array

	list=()

	# cleanup

	frobulator.clean
}

# update

frobulator.update () {
	export DEBIAN_FRONTEND=noninteractive

	command_update="apt-get update"

	frobulator.inf "Processing package and repository information."
	echo

	frobulator.log "${command_update}" &

	frobulator.progress "Updating..."
	echo
}

# upgrade

frobulator.upgrade () {
	export DEBIAN_FRONTEND=noninteractive

	command_upgrade="apt-get --assume-yes upgrade"

	frobulator.inf "Processing installed packages."
	echo

	frobulator.log "${command_upgrade}" &

	frobulator.progress "Upgrading..."
	echo
}

# purge ////////////////////////////////////////////////////////////////////////

frobulator.purge () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_purge="sudo apt-get --assume-yes purge"

	frobulator.inf "Purging selected packages."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -o installed)" ]
		then
			frobulator.wrn "Selected package" "[ '${package}' ]"
			echo

			frobulator.log "${command_purge} ${package}" &

			frobulator.progress "Purging..."
			echo
		else
			frobulator.scs "Package not installed" "[ '${package}' ]"
			echo

			frobulator.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	frobulator.clean
}

# dialog ///////////////////////////////////////////////////////////////////////

frobulator.dialog () {
	# dialog window title

	title="${script%.sh} - ${1}"

	# gtk dialog - zenity

	g_dialog () {
		zenity						\
			--file-selection		\
			--multiple				\
			--directory				\
			--separator=$'\n'		\
			--title="${title}"		"${@}"
	}

	# kde dialog - kdialog

	k_dialog () {
		kdialog						\
			--getopenfilename		\
			--multiple				\
			--separate-output		\
			--title "${title}"		"${@}"
	}

	# define dialog usage

	if [[ $(command -v zenity) ]]
	then
		dialog=$(g_dialog)

	elif [[ $(command -v kdialog) ]]
	then
		dialog=$(k_dialog)
	else
		frobulator.wrn "This utility must be run using the 'directory' option."
		echo

		frobulator.fwd "Exiting..."
		echo

		exit 1
	fi
}

# terminate ////////////////////////////////////////////////////////////////////

frobulator.terminate () {
	process_name="${1}"

	if [[ $(command -v pgrep) ]] && [[ $(command -v pkill) ]]
	then
		while [[ $(pgrep -f "${process_name}") ]]
		do
			pkill "${process_name}"
		done
	fi
}

# exit /////////////////////////////////////////////////////////////////////////

frobulator.exit () {
	instance="${1}"

	frobulator.countdown 3 "Exiting" "[ ${instance} ]"

	frobulator.kill "${SHELL}"
}

# result ///////////////////////////////////////////////////////////////////////

frobulator.result () {
	checkpoint="${1}"
	instance="${2}"

	if [[ $(command -v "${checkpoint}") ]]
	then
		frobulator.scs "Setup complete" "[ ${instance} ]"
		echo
	else
		frobulator.err "Setup errors were encountered" "[ ${instance} ]"
		echo

		frobulator.inf "Consult setup logs for details" '[ ${PREFIX}/var/log/ ]'
		echo
	fi
}

# user  ////////////////////////////////////////////////////////////////////////

frobulator.user () {
	frobulator.inf "Current user name is ${SUDO_USER:-$USER}."

	sleep 1
}

# extract //////////////////////////////////////////////////////////////////////

frobulator.extract () {
	list=(
		tar
		bunzip2
		unrar
		gunzip
		unzip
		uncompress
		7z
	)

	frobulator.require ${list[@]}

	archive="${1}"
	directory="${2}"

	if [ -z "${directory}" ]
	then
		directory="${PWD}"
	fi

	if [ ! -d "${directory}" ]
	then
		mkdir -p "${directory}"
	fi

	if [ -f "${archive}" ]
	then
		extract_message="frobulator.inf "Extracting" "['${archive}']""

		case "${archive}"
		in
			*.tar.bz2|*.tbz2)
				tar						\
					--extract			\
					--bzip2				\
					--file="${archive}" \
					--directory="${directory}"

					${extract_message}
			;;

			*.tar.gz|*.tgz)
				tar						\
					--extract			\
					--gzip				\
					--file="${archive}" \
					--directory="${directory}"

					${extract_message}

			;;

			*.tar)
				tar						\
					--extract			\
					--file="${archive}" \
					--directory="${directory}"

					${extract_message}

			;;

			*.bz2)
				bzip					\
					--stdout			\
					--keep				\
					--decompress "${archive}" > "${directory}"

					${extract_message}

			;;

			*.gz)
				gzip					\
					--stdout			\
					--keep				\
					--decompress "${archive}" > "${directory}"

					${extract_message}

			;;

			*.Z)
				uncompress 				\
					--stdout 			\
					--keep "${archive}" > "${directory}"

					${extract_message}

			;;

			*.7z)
				7z x "${archive}" -o "${directory}"

					${extract_message}

			;;

			*.rar)
				unrar e "${archive}" "${directory}"

					${extract_message}

			;;

			*.zip)
				unzip "${archive}" -d "${directory}"

					${extract_message}

			;;

			*)
				echo
				frobulator.err "Extraction failed" "[ '${archive}' ]"
				echo
			;;
		esac
	else
		echo
		frobulator.err "Unsupported archive type" "[ '${archive}' ]"
		echo
	fi
}
